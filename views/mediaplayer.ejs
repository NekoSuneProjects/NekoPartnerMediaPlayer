<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NekoSune Partner Media Player</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://www.youtube.com/iframe_api"></script>
</head>
<body class="bg-gray-900 text-white font-sans flex min-h-screen overflow-hidden">
    <!-- Sidebar (Left, Scrollable) -->
    <div id="sidebar" class="w-64 bg-gray-800 p-4 overflow-y-auto">
        <h2 class="text-xl font-bold mb-4 text-center">Playlists</h2>
        <div id="playlist-list" class="space-y-4"></div>
    </div>

    <!-- Main Content (Center) -->
    <div id="app" class="flex-1 p-4 flex flex-col items-center max-w-md mx-auto">
        <!-- Now Playing -->
        <div id="now-playing" class="mb-6 text-center">
            <img id="cover-art" class="w-48 h-48 object-cover mx-auto mb-4 rounded-lg shadow-lg" alt="Cover Art" src="https://placehold.co/150x150">
            <p id="current-song" class="text-xl font-semibold"></p>
            <p id="current-artist" class="text-lg text-gray-300"></p>
            <p id="video-stats" class="text-sm text-gray-400"></p>
            <p id="error-message" class="text-red-500 text-sm mt-2 hidden"></p>
            <input id="seek-bar" type="range" min="0" max="100" value="0" class="w-full mt-4 accent-blue-600">
        </div>

        <!-- Player Controls -->
        <div id="player-controls" class="mb-6 flex flex-col items-center space-y-4">
            <div class="flex justify-center space-x-4">
                <button id="prev-btn" class="bg-blue-600 hover:bg-blue-700 p-3 rounded-full">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/>
                    </svg>
                </button>
                <button id="play-pause-btn" class="bg-green-600 hover:bg-green-700 p-3 rounded-full">
                    <svg id="play-icon" class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.752 11.168l-6.504-3.753A1 1 0 007 8.247v7.506a1 1 0 001.248.957l6.504-3.753a1 1 0 000-1.789z"/>
                    </svg>
                    <svg id="pause-icon" class="w-6 h-6 hidden" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 9v6m4-6v6"/>
                    </svg>
                </button>
                <button id="next-btn" class="bg-blue-600 hover:bg-blue-700 p-3 rounded-full">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/>
                    </svg>
                </button>
                <button id="volume-btn" class="bg-blue-600 hover:bg-blue-700 p-3 rounded-full">
                    <svg id="volume-icon" class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.536 8.464a5 5 0 010 7.072m2.828-9.9a9 9 0 010 12.728M5 15H3v-2h2m0-2H3V9h2m6 6v-2m0-2v-2m0 6H9v-2h2m0-2H9V9h2m6 2h2m-2 2h2"/>
                    </svg>
                    <svg id="volume-mute-icon" class="w-6 h-6 hidden" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5.586 15H3v-2h2m0-2H3V9h2m6 6v-2m0-2v-2m0 6H9v-2h2m0-2H9V9h2m10 4l-2-2m0 0l-2 2m2-2l2 2m-2-2l-2-2"/>
                    </svg>
                </button>
            </div>
            <input id="volume-bar" type="range" min="0" max="100" value="50" class="w-32 mt-2 accent-blue-600 hidden">
        </div>

        <!-- Hidden Player -->
        <div id="player" class="hidden"></div>
    </div>

    <!-- Current Playlist (Right, Non-Scrollable, Below Center) -->
    <div id="playlist-display" class="w-64 bg-gray-800 p-4 flex flex-col">
        <h2 class="text-xl font-bold mb-4 text-center">Current Playlist</h2>
        <ul id="song-list" class="list-none flex-1"></ul>
    </div>

    <script>
        // Sample playlist data as fallback
        const fallbackPlaylists = [
            {
                name: 'Sample Playlist',
                cover: 'https://placehold.co/50x50',
                Songs: [
                    {
                        id: 1,
                        title: 'Sample Song 1',
                        Artist: 'Sample Artist 1',
                        cover: 'https://placehold.co/150x150',
                        youtubeid: 'dQw4w9WgXcQ',
                        views: 'N/A',
                        likes: 'N/A'
                    },
                    {
                        id: 2,
                        title: 'Sample Song 2',
                        Artist: 'Sample Artist 2',
                        cover: 'https://placehold.co/150x150',
                        youtubeid: '3tmd-ClpJxA',
                        views: 'N/A',
                        likes: 'N/A'
                    }
                ]
            }
        ];

        // Initialize localStorage for playlists
        function initializeStorage(playlistsData) {
            const stored = JSON.parse(localStorage.getItem('playlists') || '[]');

            const merged = playlistsData.map((incomingPlaylist) => {
                const existing = stored.find(p => p.name === incomingPlaylist.name); // match by name or ID

                if (!existing) return incomingPlaylist; // New playlist entirely

                const existingSongMap = new Map(existing.Songs.map(song => [song.youtubeid, song]));

               const mergedSongs = incomingPlaylist.Songs.map(song => {
                    const existingSong = existingSongMap.get(song.youtubeid);

                    if (!existingSong) return song; // New song

                    // Return latest details from incoming + preserved metadata
                    return {
                        ...song, // New title, artist, cover, etc.
                        views: existingSong.views ?? song.views,
                        likes: existingSong.likes ?? song.likes
                    };
                });

                // Include any leftover songs only in old storage (in case they were deleted in source but you want to keep them)
                const extraSongs = existing.Songs.filter(song => !mergedSongs.some(s => s.youtubeid === song.youtubeid));

                return {
                    ...incomingPlaylist, // Keep updated name/cover for playlist itself
                    Songs: [...mergedSongs, ...extraSongs]
                };
            });

            // Add brand-new playlists from localStorage if not in incoming
            const newPlaylistNames = new Set(playlistsData.map(p => p.name));
            const extraPlaylists = stored.filter(p => !newPlaylistNames.has(p.name));

            const finalPlaylists = [...merged, ...extraPlaylists];
            localStorage.setItem('playlists', JSON.stringify(finalPlaylists));
        }

        // Update metadata in background
        async function updateMetadataInBackground() {
            let playlists = JSON.parse(localStorage.getItem('playlists') || '[]');
            const songs = playlists.flatMap(p => p.Songs.map(s => ({ ...s })));

            console.log(`Starting background metadata update for ${songs.length} songs`);

            for (const song of songs) {
                await new Promise(resolve => setTimeout(resolve, 1000)); // Rate limit

                try {
                    // Simulate fetch from YouTube or other metadata source
                    const metadata = await fetchMetadata(song.youtubeid); // Implement this

                    // Update in localStorage
                    for (const playlist of playlists) {
                        const s = playlist.Songs.find(x => x.id === song.id);
                        if (s) {
                            s.views = metadata.views;
                            s.likes = metadata.likes;
                        }
                    }

                    localStorage.setItem('playlists', JSON.stringify(playlists));

                    // Optionally update UI
                    if (typeof currentPlaylist !== 'undefined') {
                        const index = currentPlaylist.findIndex(s => s.id === song.id);
                        if (index !== -1) {
                            currentPlaylist[index] = { ...currentPlaylist[index], ...metadata };
                            if (index === currentTrackIndex) updateNowPlaying();
                            updateSongList();
                        }
                    }

                    console.log(`Updated metadata for ${song.youtubeid}: Views=${metadata.views}, Likes=${metadata.likes}`);
                } catch (error) {
                    console.error(`Failed to update metadata for ${song.youtubeid}:`, error);
                }
            }

            console.log('Background metadata update completed');
        }

        let player = null;
        let playlists = [];
        let currentPlaylist = [];
        let currentTrackIndex = 0;
        let isPlaying = false;
        let sponsorBlockInterval = null;
        let isPlayerReady = false;

        // Prevent default refresh
        window.addEventListener('keydown', (e) => {
            if (
                e.key === 'F5' ||
                (e.ctrlKey && e.key === 'r') ||
                (e.metaKey && e.key === 'r')
            ) {
                e.preventDefault();
            }
        });

        // Fetch playlists from API or localStorage
        async function fetchPlaylists() {
            try {
                // Try to fetch from API
                const apiUrl = 'https://mediaplayer.nekosunevr.co.uk/api/playlists';
                const response = await fetch(apiUrl);
                if (!response.ok) {
                    throw new Error(`API request failed: ${response.status} ${response.statusText}`);
                }
                const apiData = await response.json();
                console.log('API data fetched:', JSON.stringify(apiData, null, 2));

                // Validate API data
                if (!apiData.playlists || !Array.isArray(apiData.playlists)) {
                    throw new Error('Invalid API data: playlists array missing');
                }

                initializeStorage(apiData.playlists);
                playlists = JSON.parse(localStorage.getItem('playlists') || '[]');
            } catch (error) {
                console.error('Error fetching playlists from API:', error);
                document.getElementById('error-message').textContent = 'Failed to load playlists from API. Using fallback data.';
                document.getElementById('error-message').classList.remove('hidden');
                setTimeout(() => document.getElementById('error-message').classList.add('hidden'), 3000);
                initializeStorage(fallbackPlaylists);
                playlists = JSON.parse(localStorage.getItem('playlists') || '[]');
            }

            console.log('Fetched playlists from localStorage:', JSON.stringify(playlists, null, 2));
            updatePlaylistSidebar();

            if (playlists.length > 0 && currentPlaylist.length === 0) {
                currentPlaylist = [...playlists[0].Songs];
                console.log('Initial currentPlaylist:', JSON.stringify(currentPlaylist, null, 2));
                currentTrackIndex = 0;
                updateSongList();
                if (currentPlaylist.length > 0) {
                    loadTrack(currentTrackIndex);
                }
            }

            setTimeout(updateMetadataInBackground, 0);
        }

        // YouTube Player API Ready
        function onYouTubeIframeAPIReady() {
            player = new YT.Player('player', {
                height: '0',
                width: '0',
                events: {
                    'onReady': onPlayerReady,
                    'onStateChange': onPlayerStateChange,
                    'onError': (event) => {
                        console.error('YouTube Player Error:', event.data);
                        const errorMessage = document.getElementById('error-message');
                        if (event.data === 150 || event.data === 100) {
                          console.warn(`Video ID ${currentPlaylist[currentTrackIndex]?.youtubeid} caused error ${event.data}, retrying...`);
                          setTimeout(() => {
                            if (player && isPlayerReady) {
                              player.stopVideo();
                              player.loadVideoById(currentPlaylist[currentTrackIndex].youtubeid);
                              setTimeout(() => {
                                if (player.getPlayerState() !== YT.PlayerState.PLAYING) {
                                  console.warn(`Retry failed, skipping to next.`);
                                  playNextTrack();
                                }
                              }, 3000); // wait 3 seconds before deciding to skip
                            }
                          }, 500);
                        }

                    }
                }
            });
        }

        function onPlayerReady(event) {
            isPlayerReady = true;
            player.setVolume(50);
            setInterval(updateSeekBar, 1000);
            if (currentPlaylist.length > 0) {
              setTimeout(() => loadTrack(currentTrackIndex), 500); // Small delay ensures readiness
            }
        }

        function onPlayerStateChange(event) {
            if (event.data === YT.PlayerState.ENDED) {
                playNextTrack();
            } else if (event.data === YT.PlayerState.PLAYING) {
                isPlaying = true;
                document.getElementById('play-icon').classList.add('hidden');
                document.getElementById('pause-icon').classList.remove('hidden');
                checkSponsorBlock();
                updateNowPlaying();
            } else if (event.data === YT.PlayerState.PAUSED) {
                isPlaying = false;
                document.getElementById('play-icon').classList.remove('hidden');
                document.getElementById('pause-icon').classList.add('hidden');
                if (sponsorBlockInterval) {
                    clearInterval(sponsorBlockInterval);
                    sponsorBlockInterval = null;
                }
            }
        }

        // Update Playlist Sidebar
        function updatePlaylistSidebar() {
            const playlistList = document.getElementById('playlist-list');
            playlistList.innerHTML = '';
            if (playlists.length === 0) {
                console.log('No playlists found');
                const div = document.createElement('div');
                div.textContent = 'No playlists available';
                div.classList.add('text-gray-400', 'text-center');
                playlistList.appendChild(div);
                return;
            }
            playlists.forEach((playlist, index) => {
                console.log(`Rendering playlist: ${playlist.name}, Songs: ${playlist.Songs.length}`);
                const div = document.createElement('div');
                div.classList.add('cursor-pointer', 'bg-gray-700', 'hover:bg-gray-600', 'p-2', 'rounded', 'flex', 'items-center', 'space-x-2');
                const img = document.createElement('img');
                img.src = playlist.cover || 'https://placehold.co/50x50';
                img.classList.add('w-12', 'h-12', 'object-cover', 'rounded');
                img.onerror = () => { img.src = 'https://placehold.co/50x50'; };
                const span = document.createElement('span');
                span.textContent = playlist.name || 'Unnamed Playlist';
                span.classList.add('text-sm', 'truncate');
                div.appendChild(img);
                div.appendChild(span);
                div.addEventListener('click', () => {
                    if (player && isPlayerReady) {
                        console.log(`Clicked playlist: ${playlist.name}`);
                        player.stopVideo();
                        isPlaying = false;
                        document.getElementById('play-icon').classList.remove('hidden');
                        document.getElementById('pause-icon').classList.add('hidden');
                        currentPlaylist = [...playlist.Songs];
                        console.log('Current playlist set:', JSON.stringify(currentPlaylist, null, 2));
                        currentTrackIndex = 0;
                        updateSongList();
                        if (currentPlaylist.length > 0) {
                            loadTrack(currentTrackIndex);
                        } else {
                            console.log('No songs in selected playlist');
                            document.getElementById('error-message').textContent = 'No songs in this playlist.';
                            document.getElementById('error-message').classList.remove('hidden');
                            setTimeout(() => document.getElementById('error-message').classList.add('hidden'), 3000);
                        }
                    }
                });
                playlistList.appendChild(div);
            });
        }

        // Player Controls
        document.getElementById('play-pause-btn').addEventListener('click', () => {
            if (!player || !isPlayerReady) return;
            if (isPlaying) {
                player.pauseVideo();
            } else {
                player.playVideo();
            }
        });

        document.getElementById('next-btn').addEventListener('click', () => {
            playNextTrack();
        });

        document.getElementById('prev-btn').addEventListener('click', () => {
            playPreviousTrack();
        });

        document.getElementById('volume-btn').addEventListener('click', () => {
            const volumeBar = document.getElementById('volume-bar');
            volumeBar.classList.toggle('hidden');
        });

        document.getElementById('volume-bar').addEventListener('input', (event) => {
            if (player && isPlayerReady) {
                const volume = event.target.value;
                player.setVolume(volume);
                const volumeIcon = document.getElementById('volume-icon');
                const muteIcon = document.getElementById('volume-mute-icon');
                if (volume == 0) {
                    volumeIcon.classList.add('hidden');
                    muteIcon.classList.remove('hidden');
                } else {
                    volumeIcon.classList.remove('hidden');
                    muteIcon.classList.add('hidden');
                }
            }
        });
        
        function canPlayVideo(videoId, callback) {
          fetch(`https://www.youtube.com/oembed?url=https://www.youtube.com/watch?v=${videoId}&format=json`)
          .then(res => {
            if (res.ok) return res.json();
            else throw new Error("Unplayable");
          })
          .then(() => callback(true))
          .catch(() => callback(false));
        }
        
        let trackLoadInProgress = false;

        function loadTrack(index) {
          if (!player || !isPlayerReady || !currentPlaylist[index]) return;
          const videoId = currentPlaylist[index].youtubeid;
          console.log(`Cueing track: ${currentPlaylist[index].title} (${videoId})`);
          canPlayVideo(videoId, (canPlay) => {
            if (!canPlay) {
              console.warn(`Video ${videoId} is not embeddable, skipping.`);
              playNextTrack();
              return;
            }

            player.loadVideoById(videoId);
            updateNowPlaying();
          });
        }

        function playNextTrack() {
            if (currentTrackIndex < currentPlaylist.length - 1) {
                currentTrackIndex++;
                loadTrack(currentTrackIndex);
            } else {
                console.log('End of playlist reached');
                document.getElementById('error-message').textContent = 'End of playlist reached.';
                document.getElementById('error-message').classList.remove('hidden');
                setTimeout(() => document.getElementById('error-message').classList.add('hidden'), 3000);
            }
        }

        function playPreviousTrack() {
            if (currentTrackIndex > 0) {
                currentTrackIndex--;
                loadTrack(currentTrackIndex);
            }
        }

        function updateNowPlaying() {
            if (currentPlaylist[currentTrackIndex]) {
                const song = currentPlaylist[currentTrackIndex];
                console.log(`Updating now playing: ${song.title} by ${song.Artist}`, JSON.stringify(song, null, 2));
                document.getElementById('current-song').innerHTML = 
                    song.youtubeid && song.title 
                    ? `<a href="https://www.youtube.com/watch?v=${song.youtubeid}" target="_blank" rel="noopener noreferrer">${song.title}</a>` 
                    : 'No Title';
                document.getElementById('current-artist').textContent = song.Artist || 'No Artist';
                const coverArt = document.getElementById('cover-art');
                coverArt.src = song.cover || 'https://placehold.co/150x150';
                coverArt.onerror = () => { coverArt.src = 'https://placehold.co/150x150'; };
                document.getElementById('video-stats').textContent = 
                    `Views: ${song.views || 'N/A'} | Likes: ${song.likes || 'N/A'}`;
            } else {
                console.log('No current track to display');
                document.getElementById('current-song').textContent = 'No Title';
                document.getElementById('current-artist').textContent = 'No Artist';
                document.getElementById('video-stats').textContent = 'Views: N/A | Likes: N/A';
            }
        }

        function updateSeekBar() {
            if (player && isPlayerReady && player.getDuration && player.getCurrentTime) {
                const duration = player.getDuration();
                const currentTime = player.getCurrentTime();
                if (duration > 0) {
                    const seekBar = document.getElementById('seek-bar');
                    seekBar.value = (currentTime / duration) * 100;
                }
            }
        }

        function updateSongList() {
            const songList = document.getElementById('song-list');
            songList.innerHTML = '';
            if (currentPlaylist.length === 0) {
                console.log('No songs in current playlist');
                const li = document.createElement('li');
                li.textContent = 'No songs available';
                li.classList.add('text-gray-400', 'text-center', 'p-2');
                songList.appendChild(li);
                return;
            }
            currentPlaylist.forEach((song, index) => {
                console.log(`Rendering song: ${song.title} by ${song.Artist}`, JSON.stringify(song, null, 2));
                const li = document.createElement('li');
                li.textContent = `${song.title || 'No Title'} by ${song.Artist || 'No Artist'}`;
                li.classList.add('cursor-pointer', 'hover:bg-gray-600', 'p-2', 'rounded', 'text-sm');
                li.addEventListener('click', () => {
                    console.log(`Clicked song: ${song.title} (index: ${index})`);
                    currentTrackIndex = index;
                    loadTrack(index);
                });
                songList.appendChild(li);
            });
        }

        // SponsorBlock Integration
        async function checkSponsorBlock() {
            const videoId = currentPlaylist[currentTrackIndex]?.youtubeid;
            if (!videoId) {
                console.log('No video ID for SponsorBlock');
                return;
            }
            try {
                const response = await fetch(`https://sponsor.ajay.app/api/skipSegments?videoID=${videoId}&categories=["sponsor","intro","outro","selfpromo","interaction"]`);
                const segments = await response.json();
                if (segments && segments.length > 0) {
                    if (sponsorBlockInterval) {
                        clearInterval(sponsorBlockInterval);
                    }
                    sponsorBlockInterval = setInterval(() => {
                        if (player && isPlayerReady && player.getCurrentTime) {
                            const currentTime = player.getCurrentTime();
                            segments.forEach(segment => {
                                if (currentTime >= segment.segment[0] && currentTime < segment.segment[1]) {
                                    console.log(`Skipping ${segment.category} segment: ${segment.segment[0]} to ${segment.segment[1]}`);
                                    player.seekTo(segment.segment[1], true);
                                }
                            });
                        }
                    }, 500);
                }
            } catch (error) {
                console.error('SponsorBlock error:', error);
            }
        }

        // Initialize
        fetchPlaylists();
    </script>
</body>
</html>
